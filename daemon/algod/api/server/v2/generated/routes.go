// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
