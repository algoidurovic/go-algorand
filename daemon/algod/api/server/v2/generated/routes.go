// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
