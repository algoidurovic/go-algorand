// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"F3YEd7mUkp1j6uQPl/8/AAD//ysLlcRGGQEA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
