// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
