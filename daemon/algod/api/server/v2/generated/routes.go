// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AQAA//+QQbP/uBYBAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
