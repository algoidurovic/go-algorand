// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":    true,
		"sourcemap": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------
	if paramValue := ctx.QueryParam("sourcemap"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9a3fbOJLoX8HV7jlJvKLkPGfic/rsdZJ++E6Szonds7Pbzu2GyJKEMQlwANCWOtf/",
	"/R4UABIkQUl+JOl0+1NiEY9CoVAo1PPjKBVFKThwrUYHH0cllbQADRL/omkqKq4Tlpm/MlCpZKVmgo8O",
	"/DeitGR8MRqPmPm1pHo5Go84LaBpY/qPRxL+VTEJ2ehAywrGI5UuoaBmYL0uTet6pFWyEIkb4tAOcfRq",
	"dLnhA80yCUr1ofyR52vCeJpXGRAtKVc0NZ8UuWB6SfSSKeI6E8aJ4EDEnOhlqzGZM8gzNfGL/FcFch2s",
	"0k0+vKTLBsREihz6cL4UxYxx8FBBDVS9IUQLksEcGy2pJmYGA6tvqAVRQGW6JHMht4BqgQjhBV4Vo4Of",
	"Rwp4BhJ3KwV2jv+dS4DfINFULkCPPoxji5trkIlmRWRpRw77ElSVa0WwLa5xwc6BE9NrQt5USpMZEMrJ",
	"++9eksePHz83Cymo1pA5IhtcVTN7uCbbfXQwyqgG/7lPazRfCEl5ltTt33/3Euc/dgvctRVVCuKH5dB8",
	"IUevhhbgO0ZIiHENC9yHFvWbHpFD0fw8g7mQsOOe2Ma3uinh/F90V1Kq02UpGNeRfSH4ldjPUR4WdN/E",
	"w2oAWu1LgylpBv15P3n+4ePD8cP9y3/7+TD5H/fn08eXOy7/ZT3uFgxEG6aVlMDTdbKQQPG0LCnv4+O9",
	"owe1FFWekSU9x82nBbJ615eYvpZ1ntO8MnTCUikO84VQhDoyymBOq1wTPzGpeG7YlBnNUTthipRSnLMM",
	"srHhvhdLli5JSpUdAtuRC5bnhgYrBdkQrcVXt+EwXYYoMXBdCx+4oN8vMpp1bcEErJAbJGkuFCRabLme",
	"/I1DeUbCC6W5q9TVLitysgSCk5sP9rJF3HFD03m+Jhr3NSNUEUr81TQmbE7WoiIXuDk5O8P+bjUGawUx",
	"SMPNad2j5vAOoa+HjAjyZkLkQDkiz5+7Psr4nC0qCYpcLEEv3Z0nQZWCKyBi9k9Itdn2/3P841siJHkD",
	"StEFvKPpGQGeimx4j92ksRv8n0qYDS/UoqTpWfy6zlnBIiC/oStWVAXhVTEDafbL3w9aEAm6knwIIDvi",
	"Fjor6Ko/6YmseIqb20zbEtQMKTFV5nQ9IUdzUtDVN/tjB44iNM9JCTxjfEH0ig8KaWbu7eAlUlQ820GG",
	"0WbDgltTlZCyOYOM1KNsgMRNsw0exq8GTyNZBeD4QQbBqWfZAg6HVYRmzNE1X0hJFxCQzIT85DgXftXi",
	"DHjN4MhsjZ9KCedMVKruNAAjTr1ZvOZCQ1JKmLMIjR07dBjuYds49lo4AScVXFPGITOcF4EWGiwnGoQp",
	"mHDzY6Z/Rc+ogmdPhi7w5uuOuz8X3V3fuOM77TY2SuyRjNyL5qs7sHGxqdV/h8dfOLdii8T+3NtItjgx",
	"V8mc5XjN/NPsn0dDpZAJtBDhLx7FFpzqSsLBKd8zf5GEHGvKMyoz80thf3pT5Zods4X5Kbc/vRYLlh6z",
	"xQAya1ijrynsVth/zHhxdqxX0UfDayHOqjJcUNp6lc7W5OjV0CbbMa9KmIf1UzZ8VZys/Evjqj30qt7I",
	"ASAHcVdS0/AM1hIMtDSd4z+rOdITncvfzD9lmcdwagjYXbSoFHDKgsOyzFlKDfbeu8/mqzn9YJ8HtGkx",
	"xZv04GMAWylFCVIzOygtyyQXKc0TpanGkf5dwnx0MPq3aaNVmdruahpM/tr0OsZORhC1wk1Cy/IKY7wz",
	"Ao3awCUMZ8ZPyB8sv0NRiHG7e4aGmOG9OZxTrifNQ6TFCOqT+7ObqcG3lWEsvjsPq0GEE9twBsrKtbbh",
	"PUUC1BNEK0G0opi5yMWs/uH+YVk2GMTvh2Vp8YEyITAUt2DFlFYPcPm0OULhPEevJuT7cGwUsAXP1+ZW",
	"sDKGuRTm7rpy11etMXJraEa8pwhup5ATszUeDUZ4vw2Kw8fCUuRG3NlKK6bxD65tSGbm9506fx0kFuJ2",
	"mLjw+eQwZ18u+EvwZLnfoZw+4TglzoQcdvtej2zMKHGCuRatbNxPO+4GPNYovJC0tAC6L/YSZRyfXraR",
	"hfWG3HRHRheFOTjDAa0hVNc+a1vPQxQSJIUODC9ykZ7dwnmfmXH6xw6HJ0ugGUiSUU2Dc+XOS/yyxo4/",
	"YD/kCCAjEv2P+B+aE/PZEL7hi3ZY81JnSL8i0Ktn5oFrxWY7k2mAD29BCvumJeYteiUoXzaT93iERcsu",
	"POJb+4wm2MMvwiy9UZIdzoS8Hr10CIGTRvVHqBk1OC7jzs5i06pMHH4i6gPboDNQY23pS5EhhrrDx3DV",
	"wsKxpp8AC8qMehtYaA9021gQRclyuIXzuqRq2V+Eec89fkSOfzh8+vDRL4+ePjMPklKKhaQFma01KHLf",
	"idFE6XUOD/orQ3m2ynV89GdPvMKoPW5sHCUqmUJBy/5QVhFlLy3bjJh2fay10YyrrgHc5ViegGEvFu3E",
	"6lgNaK+YMndiMbuVzRhCWNbMkhEHSQZbiemqy2umWYdLlGtZ3cbjA6QUMqIKwSOmRSry5BykYiKi1X7n",
	"WhDXwgskZfd3Cy25oIqYuVFLV/EM5CRGWXrFETSmoVDbLlQ79MmKN7hxA1Ip6bqHfrveyOrcvLvsSxv5",
	"XumjSAky0StOMphVi5bsOpeiIJRk2BEvjrciA/PuqNQtcMtmsAYYsxEhCHQmKk0o4SIDfKRUKs5HB0xc",
	"qFtHk4AOWbNe2nt6BkYgTmm1WGpSlQQV3r2tbTomNLWbkuCdqgY0grUq17ay01nzSS6BZkZQBk7EzKnd",
	"nEIQF0lRW689J3JcPPJ0aMFVSpGCUuaBY8XWraD5dnaX9QY8IeAIcD0LUYLMqbwmsFpomm8BFNvEwK3F",
	"Lqer7EO92/SbNrA7ebiNVJo3jqUCI+OZ052DhiEU7oiTc5Cos/uk++cnue72VeWARd1JKieswKcSp1wo",
	"SAXPVHSwnCqdbDu2plFLnDIrCE5K7KTiwAPP9ddUaau5ZTxD0dqyG5zHvuPNFMMAD94oZuS/+8ukP3Zq",
	"+CRXlapvFlWVpZAastgaOKw2zPUWVvVcYh6MXV9fWpBKwbaRh7AUjO+QZVdiEUR1redwpo3+4lAbYO6B",
	"dRSVLSAaRGwC5Ni3CrAbWhUHADHvsLonEg5THcqpTZnjkdKiLM3500nF635DaDq2rQ/1T03bPnFR3fD1",
	"TICZXXuYHOQXFrPWnrykRgbGkUlBz8zdhBKtVTH3YTaHMVGMp5BsonxzLI9Nq/AIbDmkA48J57ESzNY5",
	"HB36jRLdIBFs2YWhBQ+8bN5RqVnKSpQk/gbrW1eLdCeIakhIBpoyI20HH5CBI++t+xNrM+iOeT1Baych",
	"tA9+TwqNLCdnCi+MNvBnsEZV6TtrjD4JTNi3IClGRjWnm3KCgHoTl7mQwyawoqnO1+aa00tYkwuQQFQ1",
	"K5jW1rugLUhqUSbhANEH/oYZnYrFGnL9Duyi8znGoYLl9bdiPLJiy2b4TjqCSwsdTmAqhch3UEX3kBGF",
	"YCdVNSmF2XXmnFm8x4OnpBaQTohB/VrNPO+pFppxBeS/RUVSylEAqzTUN4KQyGbx+jUzmAusntMppRsM",
	"QQ4FWLkSv+ztdRe+t+f2nCkyhwvvAWYadtGxt4evpHdC6dbhuoUXrzluRxHejpoPc1E4Ga7LUyZbn/Zu",
	"5F128l1n8FpdYs6UUo5wzfJvzAA6J3O1y9pDGllStdy+dhx3J6VGMHRs3XbfpRDzW1KkxT0A8HHijPqm",
	"FZlX3AJVKfccQTuXV2iI+bj28rDe3QcEXQCW1Gvj3J+Pnj4bjRvTff3d3Mn264eIRMmyVcxBI4NVbE/c",
	"EcPX1D3z9FgriFrFkDGLecRHC+RZ7lbWYR2kAHOm1ZKVZsjGn2StoeWL+n/v/+fBz4fJ/9Dkt/3k+X9M",
	"P3x8cvlgr/fjo8tvvvl/7Z8eX37z4D//PapW1GwWV3/+YHZJzIlj8St+xK0BYy6kfY+tnZgn5p8fbi0B",
	"Mij1Mub8WUpQyBqtE2epl82mAnR0KKUU58DHhE1g0mWx2QKUVyblQOfohIhvCrGLUbQ+DpbePHEEWA8X",
	"shMfi9EPmviQNvEwm0dHvr4F4cUORGQbn/6xruxXMQ89Z91BUWuloejru2zXXwak/fdeVu4dKsFzxiEp",
	"BId1NFiEcXiDH2O97XU30BkFj6G+3bdEC/4OWO15dtnMm+IXdzvg7+9qw/YtbH533I6qM/QZRlUN5CWh",
	"JM0ZKnIEV1pWqT7lFJ+KAblGzEn+ATysPHjpm8S1FRFlghvqlFNlcFg/IKMq8DlErqzvALwOQVWLBSjd",
	"EZrnAKfctWKcVJxpnKsw+5XYDStBok1nYlsWdE3mNEddx28gBZlVui1G4qWnNMtzp3c10xAxP+VUGx6k",
	"NHnD+MkKh/MehJ5mOOgLIc9qLMSvqAVwUEwlcb7/vf2K7N8tf+muAowzsZ89v/ncfN/DHnO8c5AfvXJP",
	"rKNXKEc3Gtce7J9NDVcwnkSJzMhFBePov92hLXLfvAY8AT1odLdu10+5XnFDSOc0Z5mRna5DDl0W1zuL",
	"9nR0qKa1ER2til/rh5jbwEIkJU3P0Go8WjC9rGaTVBRT/7ScLkT9zJxmFArB8Vs2pSWbqhLS6fnDLXLu",
	"DfgVibCry/HIcR1164oYN3BsQd05a32m/1sLcu/7b0/I1O2Uume9cO3QgftkRBvgPIRaBiuzeBtFZt2Q",
	"T/kpfwVzxpn5fnDKM6rpdEYVS9W0UiBf0JzyFCYLQQ6809Erqukp77H4wUDPwN2LlNUsZyk5C6/i5mja",
	"4J3+CKenPxsCOT390LN+9C9ON1X0jNoJkguml6LSiYtOSCRcUJlFQFe1dzqObGOLNs06Jm5sS5Eu+sGN",
	"H2fVtCxV11m1v/yyzM3yAzJUzhXTbBlRWkjPBA1ntNDg/r4V7skl6YUPbakUKPJrQcufGdcfSHJa7e8/",
	"BtLy3vzV8RpDk+sSWnqjaznTdnVGuHArUMFKS5qUdAEqunwNtMTdx4u6QA1lnhPs1vIa9T4WOFSzAI+P",
	"4Q2wcFzZAw4Xd2x7+TDT+BLwE24htjHcqVH8X3e/Aj/Sa29Xxxe1t0uVXibmbEdXpQyJ+52po88Whid7",
	"a4xiC24OgQvUmwFJl5CeQYYxQ1CUej1udfcGP3fDedbBlI2ts45uGACCKrYZkKrMqJMBKF93PfEVaO3D",
	"D97DGaxPRBM/chXX+7ZDuBo6qEipwWVkiDU8tm6M7uY74zE6wZal96tGH0JPFgc1Xfg+wwfZ3pC3cIhj",
	"RNFyWB5CBJURRFjiH0DBNRZqxrsR6ceWZ8Sbmb35Imoez/uJa9JIbc4AHK4G/bDt9wIwUFdcKDKjCjIi",
	"XIypdXoOuFil6AIGdE+hlnNH1+KWZhQH2XbvRW86Me9eaL37JgqybZyYNUcpBcwXQyqoJuyY/f1MVpGO",
	"K5gQTB3hEDbLUUyqPQ4s06GypW22sfBDoMUJGCRvBA4PRhsjoWSzpMqHv2KUsD/LO8kAn9CJf1PM1lFg",
	"sQ5CgeuILM9zu+e0p7d1kVs+XMvHaIVK2x3ircYj50QV2w7BUQDKIIeFXbht7AmlCShoNsjA8eN8njMO",
	"JIkZv6lSImU2frm5ZtwcYOTjPUKs7onsPEKMjAOw0UCEA5O3IjybfHEVILkLiKB+bDQtBX9D3BPQujcZ",
	"kUeUhoUzPuCY5jkAdR4T9f3V8dvBYQjjY2LY3DnNDZtzStRmkF4EEYqtnXghZ6J8MCTOblD92YvlSmuy",
	"V9F1VhPKTB7ouEC3AeLNokRsCxTiyz19a1wN3aW7TD1wfQ/h6n4Qe3QtADqaiCY9j3v5bX2hte/m/k3W",
	"sPRxE0zrPTNjtD9EP9FdGsBfXxFcRwu9617X0Ud623TZDpQK5KcYKzZnpK8a7StgFeSAEnHSkiCSs5jC",
	"3Aj2gOz22HcLXu4YjkX5+kFgD5ewYEpDo7oyt5LXxX5ucxfF8G8h5sOr06Wcm/W9F6Lm0TbM0JrvwmV+",
	"9hWcCw3JnEmlE9T7RZdgGn2n8EX5nWkaFxTaFnebCYVlcd6A057BOslYXsXp1c37t1dm2re1EkZVszNY",
	"ozgINF2SGWbuifrhbJjaumptXPBru+DX9NbWu9tpME3NxNKQS3uOr+RcdDjvJnYQIcAYcfR3bRClGxgk",
	"XvyvINexiKVAaLCHMzMNJ5tUj73DlPmxNz2UAiiG7yg7UnQtwWt54yoYeh+Y5x7TQeKbftjAwBmgZcmy",
	"VUcRaEcdfC7SK732fWBxBwu4u26wLRgIlH4xz1QJqh1D3ki3NoURD9c22QkzJ+1I75AhhFMx5RPw9RFl",
	"SBuzRG3D1QnQ/G+w/rtpi8sZXY5HN9MbxnDtRtyC63f19kbxjAYxq0dqmQGuiHJallKc0zxx2tUh0pTi",
	"3JEmNvfK2M/M6uI6vJNvD1+/c+BfjkdpDlQmtagwuCpsV341q7Lh6gMHxCf4Mg8eL7NbUTLY/DqMONTI",
	"XizBJVMKpNFe8odG2x4cRaehncft8lv1rc4wYJe4wUAAZW0faHRX1jzQNgnQc8pyrzTy0A7Y0HFxu2UQ",
	"iXKFcIAbmxYCC1Fyq+ymd7rjp6Ohri08KZxrQ7qnwmY0U0TwrkuWESFRF4WkWlBM3WBVAn3mxKsiMccv",
	"UTlL4wpGPlOGOLg1HJnGBBsPCKNmxIoN2CF5xYKxTDO1w0O3A2QwRxSZPg3IEO5mwqWirTj7VwWEZcC1",
	"+STxVHYOKubKcKrm/nVqZIf+XG5gq55uhr+JjBGmLeneeAjEZgEjNFP1wH1VP5n9Qmt1jPkh0Mdfwdod",
	"zti7EjdYqh19OGq2LkPLtrkpzBzb53+GMGyWse1pa/3j1eVPGZgjmoaWqWQuxW8Qf+fh8zjitu4TtTD0",
	"mvwN+CQS/dNlMbV2p8mm28w+uN1D0k2ohWpb6AeoHnc+sElhUgyvnqXcbrXNCtnyC4kTTOjLNbXjNwTj",
	"YO75v+X0YkZjGUOMkGFgOmysny1FshbEd/a4dzpv5nLnTEhgSK3bMhvQVYJsIkr6wcPXFBjstDuLCo1k",
	"gFQbygRja/zKlYgMU/ELym1yUdPPHiXXW4FVfpleF0JiOKaK67wzSFlB87jkkCH22+GrGVswm1qzUhDk",
	"bnQD2ZzElopc/ktrX25QczQn++MgO6zbjYydM8VmOWCLh7bFjCrk5LUiqu5ilgdcLxU2f7RD82XFMwmZ",
	"XiqLWCVILdTh86a23MxAXwBwso/tHj4n99Fmpdg5PDBYdPfz6ODhc1S62j/2YxeAy6G7iZtkyE7+y7GT",
	"OB2j0c6OYRi3G3USDS60ic+HGdeG02S77nKWsKXjddvPUkE5XUDcTaLYApPti7uJirQOXnhms/YqLcWa",
	"MB2fHzQ1/GnA59OwPwsGSUVRMF04y4YShaGnJjGjndQPZ1MAu+xBHi7/EQ2EpbePdB6Rn1dpau+32KrR",
	"jPuWFtBG65hQG4Obs8Z07xN+kSMfyY/plOosShY3Zi6zdBRz0JI/J6VkXOPDotLz5K8kXVJJU8P+JkPg",
	"JrNnTyIppNpZY/jVAP/seJegQJ7HUS8HyN7LEK4vuc8FTwrDUbIHjY91cCoHLZlxbzHP0bvOgpuH3lUo",
	"M6Mkg+RWtciNBpz6RoTHNwx4Q1Ks13Mlerzyyj47ZVYyTh60Mjv00/vXTsoohIzldWmOu5M4JGjJ4Bwd",
	"1+KbZMa84V7IfKdduAn0X9by4EXOQCzzZzn2EHhRsTz7exMz0snCJylPl1G9/8x0/KXJklwv2Z7jaBqR",
	"JeUc8uhw9s78xd+tkdv/n2LXeQrGd2zbza5nl9tZXAN4G0wPlJ/QoJfp3EwQYrXtRF97XeYLkRGcp8lZ",
	"0VBZP2FgkEHrXxUoHQvaww/W8wP1O+ZdYBM4EeAZStUT8r2tcrIE0gqpR2mWFVVuw7MhW4B0iseqzAXN",
	"xsSMc/Lt4WtiZ7V9bMpPm0BqgcJcexWdd32Q4GY3H0KfvTPu37z7OJsdLs2qlcYMF0rTooyFrpgWJ74B",
	"xseEuk4U80LsTMgrK2ErL7/ZSQw9zJksjGRaj2Z5PNKE+Y/WNF2i6NriJsMkv3vmM0+VKkgMX+d5rXPU",
	"4LkzcLvkZzb32ZgI8764YMoWt4BzaEfL1KFj7unko2fay5MV55ZSojx6U2jjddDugbMGba8OjULWQfwV",
	"BRebOPCqieCOsVc06UM3q1wvI7yNKq5TlPqiRSnlgrMUUy4E5TRqkF2hjF1sBTtkp+gqo/wRdyc0crii",
	"uexqdyKHxcHsdp4ROsT1lZXBV7OpljrsnxorMiypJgvQynE2yMY+JaPTlzCuwOUcwpopAZ8UsmV/QQ4Z",
	"Neklter3imSEvvMDAvB35ttb9zxCp9IzxlEQcmhz/qtWo4F5/LWRnpgmCwHKracdmq9+Nn0mGJ6ewerD",
	"xOf9xzGs+cIs29rq+kMdesuds5SZti9NW2K9DuufW26KdtLDsnSTDifsjMoDesUHERyxwCReBR4gtx4/",
	"HG0DuW00ueN9aggNztFgByXewz3CqJNXdrL1ntO8shSFLYh1dYnGVzIeAeM149BUpYhcEGn0SsCNwfM6",
	"0E+lkmorAu7E006A5milizE0pZ2K9qZDdTYYUYJr9HMMb2OTd3OAcdQNGsGN8nVdDMNQdyBMvMQqPA6R",
	"/SyaKFU5ISpDt+NOXs0Y4zCM22fubV8A/WPQl4lsdy2pPTlXuYmGIslmVbYAndAsiyVre4FfCX4lWYWS",
	"A6wgrepkV2VJUozYboew96nNTZQKrqpiw1y+wQ2nCxLVRqghTJbrdxg91Wdr/DeW6Wl4Z5yx+sruUt4y",
	"jR2vLDe3R+pJvYamE8UWye6YwDvl5uhopr4eoTf9b5XSc7FoA/KZU7Js4nLhHsX427fm4gjDq3vpy+zV",
	"Ukc/o3OS8Dnv8dlYx+21uRJeZb18ZqgUr9OXb1ZLDCciH+PlN+CiGCSiofZ+tVaWIUfFdNCvlmoX3qIp",
	"2ciCMHt4bATr5WCzltuCh1EN05Bng3VsMJ97vXeTDHtyNo69EaHeZaYP0N+8Px4pKXMmxIZZ9DHrPHf7",
	"vtS7+PQ1G9xdhPOHxUFiK+mlKdxMIT1/6MCn32aTm+weV39Y22fRaoS5wBfAXTLwtqfjzv5W8zmkmp1v",
	"8T//LyOzN77NYy/V20oTgTs6q/13fF3MKz42GoA2uYdvhCdI3nFjcIa8T89gfU+RFjVE09uNPaFeJ2wT",
	"MYCJTRJDIkLF7B9WDeFU0kzVlIFY8PZG2x2anFKDeYWDaIprzuVJktAwwmLDlOci9o7ZaS7T9UpxR+iK",
	"MuSi3s/sOXx7vcJEqqrOCV8XvgxkPPNc7aadu3BhoxgtUGvefAApKP+bDw2ys9iCqk3mY9RzXlCZ+RZR",
	"wd2/CZIBp6+uG7X1VmdxoOf1zKzxDul7EkfSLaAPUJoLxfgiGXKkajtkhDWZ0OyEKhJMmYpwzUG6jOfa",
	"16tNtPDeJJvg2IQKVz/oOkhQg8kDLXCDgcfvm8hqzDFFbbViZ1ILF0gkFNRAJ4P45+E5NyH7pf3uXWd9",
	"jqGt75OaXpOtAczeL4ipHhJDqp8Td1tud8m9zlOFcW4LSqhYMDQ3qAx1aaUUWZXaCzo8GPVzbudUAxtY",
	"SVTKT/ur7AlsOSbeeB0EOJzBemqFpnRJeZMBpX2sbU5Eu4YgoLCz27f6iosLrPnCLmBxK3B+yZfQeFQK",
	"kScDyrOjfkx39wycsfQMMmLuDm9RH8gtTO6jzqa2jlws1z6GuSyBQ/ZgQoh5SxWlXntDSTubWWdyfk9v",
	"mn+Fs2aVTbPgHmmTUx53BrH1v2/I3/wwm7maAsP8bjiVHWRL0PRqIJ5c0otIpu1di6lFTBfd7McNUVko",
	"YlLKNSPodjrf/YdahPTD2Ict75+z1qvO5uvpmCuEhFt+3QV62iu+7vpRHbsuD9eBXK1S0F/nzhvQwu0A",
	"7ndBfKOa6CN3WKOgZ7toFOK5RUx3VGlYhGBiHoKgkl8f/kokzDFRnyB7ezjB3t7YNf31UfuzeX3t7UVP",
	"5mdTZrRqtrl5YxTz9yHztjXhDnhSdPajYnm2jTBafjFN0kz0/PjFeRB9kbSdv9gncv+ougyGV1GjdjcB",
	"ERNZa2vyYKrA42UHZxfXbRKtqqcgrSTTawxs8i8q9ks0YPz7WgnjCoHWrvDOE9uW3HeOWY3KpqmS/r2w",
	"VfgKc9ejEltjWYFvV7Qoc3AH5Zt7s7/A478+yfYfP/zL7K/7T/dTePL0+f4+ff6EPnz++CE8+uvTJ/vw",
	"cP7s+exR9ujJo9mTR0+ePX2ePn7ycPbk2fO/3PMlyi2gTfnvf2Bu2+Tw3VFyYoBtcEJLVlcTMWTs82TS",
	"FE+ieZPkowP/0//2J2ySiqIZ3v86cl56o6XWpTqYTi8uLiZhl+kC32iJFlW6nPp5+lUc3h3VHkQ28gN3",
	"1DqHGFLATXWkcIjf3n97fEIO3x1NGoIZHYz2J/uTh5iOugROSzY6GD3Gn/D0LHHfp47YRgcfL8ej6RJo",
	"jjnKzR8FaMlS/0ld0MUC5MQlDDU/nT+aegeE6Uf3Pr00oy5iIV/WFyosdNzLo+l0XWhQsr5OrbxUyqVJ",
	"GtfZypz4yDN0UbFPPsPaamQdZU1mkqOgeq6Lz7IB6wc/R/I3z9mikp36R7U236UyZIrYYpaSvLE693c0",
	"PQvdQGLl6B0ri1Wjd84ihVqUbctqo+mPVUqJJSTFmc0+B5Raq4oaTqRlBSEkDV81vHI/ef7h49O/Xo52",
	"AAT1lq4e7680z3+1BapghcqfdmlsNR6qwz5uVA+d6tdjNA3XX8NEmXWbtkPSr1xw+HVoGxxg0X2geW4a",
	"Cg6xPfjQKfv/aH//E1TQHrdG8STxRUtxP7nFhbYtaDdebne43qJf0AyTF4LSdikPv9qlHHE0HRiOT+yN",
	"djkePf2K9+aIG55Dc4ItgzCs/i3yEz/j4oL7lkaaqYqCyjXKKkGG1VAqvRy8raZhNrjpx5ZiObvRXdZL",
	"hHn0asv1dk8NMcV+foJOsjnzvU6nhqpHl1EPVkxp9WBCvg97I2NGd3/rTF9J3pRsKqU4Z5lhsc4m56Mi",
	"G9juqTASInrZBq/1u3v3k967h22tQyvAPQZMi8Q3wtSzPN304uu7X3VyhV8rF3eQ1u4ayYE+acLSbnHv",
	"oSqKOzDYO9wNVaAcEG8CeGtJp52O8NPzXft+C66J1n3wCbnyVy6svaG5oZNguR1XcJv14U6I+9MIcbUz",
	"gi35gYmONol1mM10+tEn6bgFUc4lKdlBiAtfukHfIInE/Q6neDCxGTfCNtdjB86xYKt4hqlT7gSzTy2Y",
	"9XMOxcBoMsl8OWEMYVg2SYmuUmejlUP4SsmTvlLp60+MrEFxy0C6XdC6Bm/sCVGOE38ynvmHFJ4c0u7E",
	"pj+12GR9+TYITq2EYM7xc1h2gqD8d1BSpeV4Nlt7OhwTJaRzfyolE5Lp9ZgwTjIwZw8thkJi7HNTSNw5",
	"GQHH/745/Ae6nr45/Af5huyPaxEMQ8Mi01vnnrYM9D3oSKH7F+vDWhzYKAv9bgSMkxpJA4XotfA5vRBp",
	"BV19M4SylbUrxsSzgq5GGyWR8dcjLd5UaOoEdfapyNXytIXsXf2ZtkuVIrCiqc7XhOL9s7a+v1ji3Cfk",
	"6hRl7xTKj8YbbZjRl7eIRY1d1asrEjnfq84/ULV4iEpd4jusJbNdMOkhIwrB9aS8u939ane3L5aSUpgz",
	"zTAzQ3Of+LuqBWRT5MCBO+CwOiH/LSp0drE1vCCWVRRnQOdeP6cTQIO0wDlWUKuxs7fXXfjenttzpsgc",
	"LpCDUo4Nu+jY2/sDiKyrOpkjJVzwhGOJqXMggYfcndz6u5Zbn+4//mpXcwzynKVATqAohaSS5WvyE6+z",
	"39xMLK95TsWDfEQb+U/PU76RogPx/Ua2665tmulGMmwFTgUqhLoSoHsrj5tSAuYtj1lLfMC6GnvTCTr+",
	"WauK3Y9xz7AyiQnpgQXnxfro1S5y+VdiCN05e1bkXovvzae+AaL+NO8/jz/Nbsz0yf6TzwdBuAtvhSbf",
	"obrsE7P0T6o7iJNVwGyubFFpLCYha3GBiBuZijmhY5fxFFNwrkkdKGT4iWWEtuZBn2uYGXblF79j/fwO",
	"1X4jdNlF7x1fuOMLN+ILXYJqOAKG26vpRzQVhOygdyRfmJZ/IBNjYG+RovAGF0HmoNOlTUPQDYuJsBWf",
	"hG+Yp2xKVX/L9j8EOpIDCtfiQj8whfqOAYHY8QcbiXE5HqUgI8T3o8+HYz6zOYZ11gkWfUUGNOcwn6S4",
	"zk/ssrgz5X3OXdYbYnbxSlC+bCbvh+kgWm7DZniH4KshuMfUvnXpou3xcov4I3il+1zCCXmL4hAecJ9f",
	"8I+o9viUN/KnXtBbwcHapY3EamnxzgRZiwtY1AWR4rMgWMOjqxMbFx3aRsePesWyy2mdpmdIqHiHDbYI",
	"Fc1NzZpSmm31Ci1LoFJd+5Lebg476cx49Cr002hlFarzCUVAMXi5oiXxP0Y7SjMY8CPmZEnVkswrbgGt",
	"izahy4p3ohDzca2sNadBzA/IKd8jakmfPnz0y6Onz/yfj54+G5DHzDwu/rgvkTUDmc92mF3Esj+u2bEt",
	"StTIO/jcW3m1HRqPWLaKphCBlc+EFJ4Lp/tE5nBPkZKuBzMPDSTxegPyLPd1z9tGHlKAuVDVkpVfoo47",
	"m8VLGf1gdknMSZ1g/Ii/qPnnOUg2x3pcNV/4zJlhJEAGpV5uTMlgy4mVetlsKriCl0y51DelFOfAx4RN",
	"YNI1hmWLJldvDnRep04RYhdXtYCXGHrzxBFgPVzILqLmuxj9YDikSzH3uZUqjUuXvcw88mTnXvmiGhf9",
	"RTQubwVPUB4Drv3boIWWL6d9wWw340DBWZds4EKjYlNIFCNDtqUmOwlgMGhsavFA6zo5SMZOHEupTpdV",
	"Of2I/8HMA5dNjL+tTzK1ithNEtmxbXGrLjZ2TCLb3MYnu3DKYTEnb1gqxSFmRXLXiForDUW/eqXt+sum",
	"yhfRK0fwnHFICsFjeTJ+xK9v8GM07xKa7Qc6owPFUN9uzaEW/B2w2vPswupuit/J70PJe6MHS2e1Esra",
	"TRH9OZD+m9PSSnzbHJPWz9OPrT+dvcS1VMtKZ+Ii6GvzWmw8W7bFrZ6ttyIDO247lUzMf5SLDFz6jf6R",
	"qrlGXCL1+G3adYSDlFaLpbbVF6OlXeuOCU3tUbC5Y9W2ZJu2lU8qdw6E5hJotiYzAE7EzCy6nbSYUFWX",
	"00XisLwxnjOygauUIgWlIEvCskubQKuTmqDkozfgCQFHgOtZiBJkTuU1gbVMYjOg3XqDNbi1ptDxgT7U",
	"u02/aQO7k4fbSCUQzxDxRSOKMgf3pomgcEecoKzNPvH++Umuu31ViZV9IllP7dcTVmDeDk65UJAKnqnh",
	"3MTbji1mIw7WosAWs/UnJVowxQw8cLW+pkq7wlKtFI5BTmszxYZkykMJyczIf6/TkfXGTg2/5KpSTc0t",
	"K3tBFi1nCqsNc72FVT2XmAdj18KdLbW8beQhLAXj11W4guzIOtBimeEii8MgGOpEsT4qW0A0iNgEyLFv",
	"FWA31LAMAMJUg+g65WmbcoIyyEqLsjTnTycVr/sNoenYtj7UPzVt+8TlggeQr2cCVCh4O8gvLGZtgb0l",
	"VcTBQQp65mT2hfPh78NsDmOiGE9dSveh+CxWwLFpFR6BLYe0K/aFx791zjqHo0O/UaIbJIItuzC04Jig",
	"+bsQC6/67uvq7T6hqrwtaAfiVSNo2r+nF5TpZC6kS5ePJdwjVvdONi7KtHLPP/sq1sKpul0ReMtQ3DhB",
	"eUkVOkBbEHwQjtn9vs+Nmeo7IXcy8jf6eC2IWRipuGY+ktqct1rG/P1ZzO+k5zvp+U56vpOe76TnO+n5",
	"Tnq+k54/tfT8Zbx2SZJ4Pu1Nw7GALDL6KiX8ryjm6XMGKTVCfy3y4yPBiOjmHG/05tFA86kr6ozeCkIN",
	"hgWEBaJTMx3jpMypkYZgpX1wOplRBc+eeJ+MugamTd9veI1p8PgROf7h0DsqLJ0lvd32vq8sp/Q6hwfO",
	"67HOr+3dH4FTrLiJ3o/Uv35S51Bihfk5y4Eog6tvsfUrOIfcSPLW+EnMW6T/OjoBmr90uNnyOGplUDaj",
	"/Tpuvckc2gpaepHHr5UqQtGppZMAeU5zNZwB2Y5X0DIW3l/zaftsQtbwQmTrDrmbXZviBrYJvfFTYJzK",
	"SHHlPnn3SEMLLLDuqoX33n2Xt+5U0yfaPplto7B4KZl4EeRNVD5co9tsWG8o69E079BJNP1/13diVAO4",
	"i8HQ0LPfE+KqO3/R24ogRO6INZz5dxN40q2t55gGtjUClWM9X2uQiEd89PTi2R/72mOEaUUcxa0S02gB",
	"PHG8JZmJbJ20OFP7gmlK8m69ZELWiIepvlfq0vGDV9CXuSGCss+jTew2pIdV4njrAOO1DmK7sd0aWzii",
	"47wBxj819x3ikCEIxLGe2Nu5m73sivwsKPd8x9PueFpwGjuXPePON7HLRCbX42lYIX2YnX1rCwYqEh7S",
	"++qBYVmI0ZVuae4zmFWLha2S19VCYxatutjjl+Fydrm7MrirEYcdvA49vWnURHe4PuMInOruC0kWUlTl",
	"A5vTkK9RwVmUlK+9UcO8/Isqd8VvMdLrdnloXbGxJzd65dqwXu6dV78F2id3i7Z/t2jBOo92fyEjFc9A",
	"xsuprTpFsrZj/GTFGw68sYSWLybYW52bdxfu73fZRQjUhpzSlla1B6p1mJyfsj25k7vw6j/HjfDO5g4d",
	"YLB9L9uGIWy/GGTAsvBm6CTb8ldDm5++pxdh6q7bEhp3f60vAe/E+vUayUxmxEgpaJZShUoNDvpCyLNP",
	"LEvq1VFEi4xgYobJfuCJeZNMtgqVOO5OImU71su/yqtZwZStyvdlhcsmmuDQBey2sHGn2P2jKHZf+MOn",
	"CMUCv53DaW04eCZ3YFP0Qq94lEtNS5uhesh/OTgQLpf1rXpi9IZvO2QE+aGtQRnyklCS5gzNzYIrLatU",
	"n3KKBq1O9eOOs4Y30w2LUi99k7hNNWLydEOdciNUzUlt5oqKVHOIGLC/A/ASm6oWC1C6w4nnAKfctWKc",
	"VJxpnAuLSSfWr99c14ajT2zLgq7JnOZokf0NpCAz84gIs5aheUhplufOO8RMQ8T8lFNNcjBM/w0zAp0Z",
	"zlsQao8nS3c1FgaK5NvylElcO/u9/YoxdG753gqAxgr72Ue7jL9MEdmEZYOQH71yGUWPXmGSuMYvpAf7",
	"Z3MWKBhPokRmbnznX9WlLXLfyHiegB40HiZu10+5Eaa1IMjoqb4eOXSNur2zaE9Hh2paG9Gx/fq1fohl",
	"s1iIxDwZ6cL8vmB6Wc2wjKvPcjFdiDrjxTSjUAiO37IpLdlUlZBOzx9ukQ9uwK9IhF3d3dx/HJNsSAfm",
	"tNQbj5UTuns/cC/fQgL333fW9q0Op3c50u9ypN9l0b7LkX63u3c50u8yiN9lEP+zZhCfbJQQXdatrTl9",
	"dU+1SYmE1M5cM/CwWSv7b98qyfSEkJOl4f/U3AFwDpLmJKXKCkbc+j0XbLHURFVpCpAdnPKkBUkqCjfx",
	"/ea/9pl7Wu3vPway/6Dbx+otAs7b74uiKn5CUxP5hpyOTke9kSQU4hxcLlBsnlXo/mJ7bR32f9Xj/ih7",
	"W1fQtVWuLGlZgrnWVDWfs5RZlOfCPAYWouOtzQV+AWmAs3mPCNM27TriE73cnU8MddlEYkJ3/36/QtHI",
	"w252ms+a1uyPK2Bv4lP9Dbs9Hrhx7B5DvGMZn4NlfHGm8QfKwHqXbPV3tqDQkNrKpn4DSaouIxrRO3kZ",
	"yaqTDW/GESCtJNNrvOFoyX45A/P/D4aPK5Dn/vKrZD46GC21Lg+mU6x3shRKT0fmamq+qc5Hcz/QhR3B",
	"XS6lZOeYK/nD5f8PAAD//6D+0PM5GQEA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
