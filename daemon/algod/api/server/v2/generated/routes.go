// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":  true,
		"format":  true,
		"exclude": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":   true,
		"hashtype": true,
		"format":   true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "hashtype" -------------
	if paramValue := ctx.QueryParam("hashtype"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET("/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AP//tuPpbgUYAQA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
